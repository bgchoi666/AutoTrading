# Copyright 2022 Bimghi Choi. All Rights Reserved.

# -*- coding:utf-8 -*-

# 기간별 추천 앙상블의 15일 단위 수익률 생성
# 예) 2017-12-31 ~ 2021-12-31 의 trained 모델들의 15일 간격 앙상블 수익률 list

import make_model as tm
import profit
import ensemble_test as et
import matplotlib.pyplot as plt
import matplotlib.ticker as ticker
import openpyxl
import pandas as pd
import numpy as np
from datetime import datetime
import os
import random

last_trains = [
    '2016-12-31',
    '2017-01-15', '2017-01-31', '2017-02-15', '2017-02-28',
    '2017-03-15', '2017-03-31', '2017-04-15', '2017-04-30',
    '2017-05-15', '2017-05-31', '2017-06-15', '2017-06-30',
    '2017-07-15', '2017-07-31', '2017-08-15', '2017-08-31',
    '2017-09-15', '2017-09-30', '2017-10-15', '2017-10-31',
    '2017-11-15', '2017-11-30', '2017-12-15',

    '2017-12-31',
    '2018-01-15', '2018-01-31', '2018-02-15', '2018-02-28',
    '2018-03-15', '2018-03-31', '2018-04-15', '2018-04-30',
    '2018-05-15', '2018-05-31', '2018-06-15', '2018-06-30',
    '2018-07-15', '2018-07-31', '2018-08-15', '2018-08-31',
    '2018-09-15', '2018-09-30', '2018-10-15', '2018-10-31',
    '2018-11-15', '2018-11-30', '2018-12-15',

    '2018-12-31',
    '2019-01-15', '2019-01-31', '2019-02-15', '2019-02-28',
    '2019-03-15', '2019-03-31', '2019-04-15', '2019-04-30',
    '2019-05-15', '2019-05-31', '2019-06-15', '2019-06-30',
    '2019-07-15', '2019-07-31', '2019-08-15', '2019-08-31',
    '2019-09-15', '2019-09-30', '2019-10-15', '2019-10-31',
    '2019-11-15', '2019-11-30', '2019-12-15',

    '2019-12-31',
    '2020-01-15', '2020-01-31', '2020-02-15', '2020-02-28',
    '2020-03-15', '2020-03-31', '2020-04-15', '2020-04-30',
    '2020-05-15', '2020-05-31', '2020-06-15', '2020-06-30',
    '2020-07-15', '2020-07-31', '2020-08-15', '2020-08-31',
    '2020-09-15', '2020-09-30', '2020-10-15', '2020-10-31',
    '2020-11-15', '2020-11-30', '2020-12-15',

    '2020-12-31',
    '2021-01-15', '2021-01-31', '2021-02-15', '2021-02-28',
    '2021-03-15', '2021-03-31', '2021-04-15', '2021-04-30',
    '2021-05-15', '2021-05-31', '2021-06-15', '2021-06-30',
    '2021-07-15', '2021-07-31', '2021-08-15', '2021-08-31',
    '2021-09-15', '2021-09-30', '2021-10-15', '2021-10-31',
    '2021-11-15', '2021-11-30', '2021-12-15',

    '2021-12-31',
    '2022-01-15', '2022-01-31', '2022-02-15', '2022-02-28',
    '2022-03-15', '2022-03-31', '2022-04-15', '2022-04-30',
    '2022-05-15', '2022-05-31', '2022-06-15', '2022-06-30',
    '2022-07-15', '2022-07-31', '2022-08-15', '2022-08-31',
    '2022-09-15', '2022-09-30', '2022-10-15', '2022-10-31',
    '2022-11-15', '2022-11-30', '2022-12-15',

    '2022-12-31',
    '2023-01-15', '2023-01-31', '2023-02-15', '2023-02-28',
    '2023-03-15', '2023-03-31', '2023-04-15', '2023-04-30',
    '2023-05-15', '2023-05-31', '2023-06-15', '2023-06-30',
    '2023-07-15', '2023-07-31', '2023-08-15', '2023-08-31',
    '2023-09-15', '2023-09-30', '2023-10-15', '2023-10-31',
    '2023-11-15', '2023-11-30', '2023-12-15',
]

start_times = [
    '2017/01/01/09:00', '2017/01/16/09:00', '2017/02/01/09:00', '2017/02/16/09:00',
    '2017/03/01/09:00', '2017/03/16/09:00', '2017/04/01/09:00', '2017/04/16/09:00',
    '2017/05/01/09:00', '2017/05/16/09:00', '2017/06/01/09:00', '2017/06/16/09:00',
    '2017/07/01/09:00', '2017/07/16/09:00', '2017/08/01/09:00', '2017/08/16/09:00',
    '2017/09/01/09:00', '2017/09/16/09:00', '2017/10/01/09:00', '2017/10/16/09:00',
    '2017/11/01/09:00', '2017/11/16/09:00', '2017/12/01/09:00', '2017/12/16/09:00',

    '2018/01/01/09:00', '2018/01/16/09:00', '2018/02/01/09:00', '2018/02/16/09:00',
    '2018/03/01/09:00', '2018/03/16/09:00', '2018/04/01/09:00', '2018/04/16/09:00',
    '2018/05/01/09:00', '2018/05/16/09:00', '2018/06/01/09:00', '2018/06/16/09:00',
    '2018/07/01/09:00', '2018/07/16/09:00', '2018/08/01/09:00', '2018/08/16/09:00',
    '2018/09/01/09:00', '2018/09/16/09:00', '2018/10/01/09:00', '2018/10/16/09:00',
    '2018/11/01/09:00', '2018/11/16/09:00', '2018/12/01/09:00', '2018/12/16/09:00',

    '2019/01/01/09:00', '2019/01/16/09:00', '2019/02/01/09:00', '2019/02/16/09:00',
    '2019/03/01/09:00', '2019/03/16/09:00', '2019/04/01/09:00', '2019/04/16/09:00',
    '2019/05/01/09:00', '2019/05/16/09:00', '2019/06/01/09:00', '2019/06/16/09:00',
    '2019/07/01/09:00', '2019/07/16/09:00', '2019/08/01/09:00', '2019/08/16/09:00',
    '2019/09/01/09:00', '2019/09/16/09:00', '2019/10/01/09:00', '2019/10/16/09:00',
    '2019/11/01/09:00', '2019/11/16/09:00', '2019/12/01/09:00', '2019/12/16/09:00',

    '2020/01/01/09:00', '2020/01/16/09:00', '2020/02/01/09:00', '2020/02/16/09:00',
    '2020/03/01/09:00', '2020/03/16/09:00', '2020/04/01/09:00', '2020/04/16/09:00',
    '2020/05/01/09:00', '2020/05/16/09:00', '2020/06/01/09:00', '2020/06/16/09:00',
    '2020/07/01/09:00', '2020/07/16/09:00', '2020/08/01/09:00', '2020/08/16/09:00',
    '2020/09/01/09:00', '2020/09/16/09:00', '2020/10/01/09:00', '2020/10/16/09:00',
    '2020/11/01/09:00', '2020/11/16/09:00', '2020/12/01/09:00', '2020/12/16/09:00',

    '2021/01/01/09:00', '2021/01/16/09:00', '2021/02/01/09:00', '2021/02/16/09:00',
    '2021/03/01/09:00', '2021/03/16/09:00', '2021/04/01/09:00', '2021/04/16/09:00',
    '2021/05/01/09:00', '2021/05/16/09:00', '2021/06/01/09:00', '2021/06/16/09:00',
    '2021/07/01/09:00', '2021/07/16/09:00', '2021/08/01/09:00', '2021/08/16/09:00',
    '2021/09/01/09:00', '2021/09/16/09:00', '2021/10/01/09:00', '2021/10/16/09:00',
    '2021/11/01/09:00', '2021/11/16/09:00', '2021/12/01/09:00', '2021/12/16/09:00',

    '2022/01/01/09:00', '2022/01/16/09:00', '2022/02/01/09:00', '2022/02/16/09:00',
    '2022/03/01/09:00', '2022/03/16/09:00', '2022/04/01/09:00', '2022/04/16/09:00',
    '2022/05/01/09:00', '2022/05/16/09:00', '2022/06/01/09:00', '2022/06/16/09:00',
    '2022/07/01/09:00', '2022/07/16/09:00', '2022/08/01/09:00', '2022/08/16/09:00',
    '2022/09/01/09:00', '2022/09/16/09:00', '2022/10/01/09:00', '2022/10/16/09:00',
    '2022/11/01/09:00', '2022/11/16/09:00', '2022/12/01/09:00', '2022/12/16/09:00',

    '2023/01/01/09:00', '2023/01/16/09:00', '2023/02/01/09:00', '2023/02/16/09:00',
    '2023/03/01/09:00', '2023/03/16/09:00', '2023/04/01/09:00', '2023/04/16/09:00',
    '2023/05/01/09:00', '2023/05/16/09:00', '2023/06/01/09:00', '2023/06/16/09:00',
    '2023/07/01/09:00', '2023/07/16/09:00', '2023/08/01/09:00', '2023/08/16/09:00',
    '2023/09/01/09:00', '2023/09/16/09:00', '2023/10/01/09:00', '2023/10/16/09:00',
    '2023/11/01/09:00', '2023/11/16/09:00', '2023/12/01/09:00', '2023/12/16/09:00',
]

end_times = [
    '2017/01/15/15:00', '2017/01/31/15:00', '2017/02/15/15:00', '2017/02/28/15:00',
    '2017/03/15/15:00', '2017/03/31/15:00', '2017/04/15/15:00', '2017/04/30/15:00',
    '2017/05/15/15:00', '2017/05/31/15:00', '2017/06/15/15:00', '2017/06/30/15:00',
    '2017/07/15/15:00', '2017/07/31/15:00', '2017/08/15/15:00', '2017/08/31/15:00',
    '2017/09/15/15:00', '2017/09/30/15:00', '2017/10/15/15:00', '2017/10/31/15:00',
    '2017/11/15/15:00', '2017/11/30/15:00', '2017/12/15/15:00', '2017/12/31/15:00',

    '2018/01/15/15:00', '2018/01/31/15:00', '2018/02/15/15:00', '2018/02/28/15:00',
    '2018/03/15/15:00', '2018/03/31/15:00', '2018/04/15/15:00', '2018/04/30/15:00',
    '2018/05/15/15:00', '2018/05/31/15:00', '2018/06/15/15:00', '2018/06/30/15:00',
    '2018/07/15/15:00', '2018/07/31/15:00', '2018/08/15/15:00', '2018/08/31/15:00',
    '2018/09/15/15:00', '2018/09/30/15:00', '2018/10/15/15:00', '2018/10/31/15:00',
    '2018/11/15/15:00', '2018/11/30/15:00', '2018/12/15/15:00', '2018/12/31/15:00',

    '2019/01/15/15:00', '2019/01/31/15:00', '2019/02/15/15:00', '2019/02/28/15:00',
    '2019/03/15/15:00', '2019/03/31/15:00', '2019/04/15/15:00', '2019/04/30/15:00',
    '2019/05/15/15:00', '2019/05/31/15:00', '2019/06/15/15:00', '2019/06/30/15:00',
    '2019/07/15/15:00', '2019/07/31/15:00', '2019/08/15/15:00', '2019/08/31/15:00',
    '2019/09/15/15:00', '2019/09/30/15:00', '2019/10/15/15:00', '2019/10/31/15:00',
    '2019/11/15/15:00', '2019/11/30/15:00', '2019/12/15/15:00', '2019/12/31/15:00',

    '2020/01/15/15:00', '2020/01/31/15:00', '2020/02/15/15:00', '2020/02/28/15:00',
    '2020/03/15/15:00', '2020/03/31/15:00', '2020/04/15/15:00', '2020/04/30/15:00',
    '2020/05/15/15:00', '2020/05/31/15:00', '2020/06/15/15:00', '2020/06/30/15:00',
    '2020/07/15/15:00', '2020/07/31/15:00', '2020/08/15/15:00', '2020/08/31/15:00',
    '2020/09/15/15:00', '2020/09/30/15:00', '2020/10/15/15:00', '2020/10/31/15:00',
    '2020/11/15/15:00', '2020/11/30/15:00', '2020/12/15/15:00', '2020/12/31/15:00',

    '2021/01/15/15:00', '2021/01/31/15:00', '2021/02/15/15:00', '2021/02/28/15:00',
    '2021/03/15/15:00', '2021/03/31/15:00', '2021/04/15/15:00', '2021/04/30/15:00',
    '2021/05/15/15:00', '2021/05/31/15:00', '2021/06/15/15:00', '2021/06/30/15:00',
    '2021/07/15/15:00', '2021/07/31/15:00', '2021/08/15/15:00', '2021/08/31/15:00',
    '2021/09/15/15:00', '2021/09/30/15:00', '2021/10/15/15:00', '2021/10/31/15:00',
    '2021/11/15/15:00', '2021/11/30/15:00', '2021/12/15/15:00', '2021/12/31/15:00',

    '2022/01/15/15:00', '2022/01/31/15:00', '2022/02/15/15:00', '2022/02/28/15:00',
    '2022/03/15/15:00', '2022/03/31/15:00', '2022/04/15/15:00', '2022/04/30/15:00',
    '2022/05/15/15:00', '2022/05/31/15:00', '2022/06/15/15:00', '2022/06/30/15:00',
    '2022/07/15/15:00', '2022/07/31/15:00', '2022/08/15/15:00', '2022/08/31/15:00',
    '2022/09/15/15:00', '2022/09/30/15:00', '2022/10/15/15:00', '2022/10/31/15:00',
    '2022/11/15/15:00', '2022/11/30:15:00', '2022/12/15/15:00', '2022/12/31/15:00',


    '2023/01/15/15:00', '2023/01/31/15:00', '2023/02/15/15:00', '2023/02/28/15:00',
    '2023/03/15/15:00', '2023/03/31/15:00', '2023/04/15/15:00', '2023/04/30/15:00',
    '2023/05/15/15:00', '2023/05/31/15:00', '2023/06/15/15:00', '2023/06/30/15:00',
    '2023/07/15/15:00', '2023/07/31/15:00', '2023/08/15/15:00', '2023/08/31/15:00',
    '2023/09/15/15:00', '2023/09/30/15:00', '2023/10/15/15:00', '2023/10/31/15:00',
    '2023/11/15/15:00', '2023/11/22/15:00', '2023/12/15/15:00', '2023/12/31/15:00',
]

length = len(last_trains)

et.trading_9h = False
et.profit.loss_cut = 0.01
et.target_type = 'C'

import make_reinfo as mr
et.mr = mr
et.tm.mr = mr

hit_ratios = [0.2, 0.3, 0.4, 0.5]
eval_terms = [2, 3, 4, 5, 6, 7]

model_pools = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# 고정된 랜덤 앙상블 조합에 대한 주어진 기간에서의 수익률 조사를 원하는 경수 사용
#random_ensemble = list(random.sample(model_pools, 3))
#random_model = [str(random_ensemble[0]), str(random_ensemble[1]), str(random_ensemble[2]), random.sample(hit_ratios, 1)[0],
#     random.sample(eval_terms, 1)[0]]

models = [

["4", "7", "8", 0.5, 7],
["4", "8", "9", 0.3, 4],
["1", "3", "9", 0.4, 2],
["2", "4", "8", 0.3, 7],
["1", "9", "10", 0.4, 2],
["1", "8", "10", 0.5, 7],
["6", "8", "9", 0.5, 5],
["1", "4", "6", 0.5, 5],
["2", "4", "8", 0.3, 6],
["6", "8", "9", 0.3, 5],
["1", "2", "6", 0.5, 2],
["1", "5", "10", 0.5, 6],
["3", "8", "10", 0.3, 7],
["1", "5", "7", 0.5, 7],
["1", "8", "9", 0.5, 5],
["2", "4", "6", 0.3, 2],
["2", "6", "9", 0.3, 2],
["8", "9", "10", 0.3, 7],
["3", "6", "10", 0.3, 2],
["2", "3", "7", 0.4, 6],


]

every_term_random = False
random_cnt = 20

start_time = '2017/04/16/09:00'
end_time = '2023/04/15/15:00'

start_index = start_times.index(start_time)
end_index = end_times.index(end_time)

last_trains = last_trains[start_index:end_index+1]
start_times = start_times[start_index:end_index+1]
end_times = end_times[start_index:end_index+1]

del_start_index = start_times.index("2020/01/01/09:00")
del_end_index = end_times.index("2020/12/31/15:00")

last_trains = last_trains[start_index:del_start_index] + last_trains[del_end_index+1:end_index+1]
start_times = start_times[start_index:del_start_index] + start_times[del_end_index+1:end_index+1]
end_times = end_times[start_index:del_start_index] + end_times[del_end_index+1:end_index+1]

if every_term_random:
    add_txt = "_every_term_random"
else:
    add_txt = "_2020제외_4월26일"

term = datetime.strptime(start_time, "%Y/%m/%d/%H:%M").strftime("%Y-%m-%d") + "~" + \
       datetime.strptime(end_time, "%Y/%m/%d/%H:%M").strftime("%Y-%m-%d") + add_txt

folder = "앙상블실험3/앙상블실험3_"+term+"_losscut"+str(et.profit.loss_cut)+"/"
if not os.path.isdir(folder):
    os.makedirs(folder)


def main():

    # 모델별 각 구간별 수익률 계산, 저장
    profit_sum = []
    profit_product = 1
    dates = []
    closes = []
    for i in range(len(last_trains)):
        et.last_train = last_trains[i]
        et.start_time = start_times[i]
        et.end_time = end_times[i]

        et.weights = [1 for i in range(et.selected_num)]
        et.selected_checkpoint_path = ['' for i in range(et.selected_num)]

        et.df_pred_path = et.last_train + '/kospi200f_60M_pred.csv'
        et.df_raw_path = et.last_train + '/kospi200f_60M_raw.csv'
        et.result_path = et.last_train + '/pred_88_results.csv'

        if every_term_random:

            et.selected_model_types = list(map(str, sorted(random.sample(model_pools, et.selected_num))))
            et.reinfo_th = random.sample(hit_ratios, 1)[0]
            et.model_reinfo_th = et.reinfo_th
            et.pred_term = random.sample(eval_terms, 1)[0]


        for j in range(et.selected_num):
            et.selected_checkpoint_path[j] = et.last_train + "/60M_" + et.selected_model_types[j] + "_best"

        et.preprocessing()
        p = et.predict()
        print(last_trains[i] + " 수익률: " + str(p))
        profit_sum.append(p)
        profit_product *= p

        df = pd.read_csv(et.result_path, encoding='euc-kr')
        dates.append(df['date'].values[0])
        closes.append(df['close'].values.mean())

    profit_rates = (np.array(profit_sum) - 1).cumsum() + 1
    close_rates = (np.array(closes) - closes[0])/(np.array(closes).mean()*0.078) + 1

    print("평균: ", str(np.array(profit_sum).mean()))
    print("복리누적: " + str(profit_product))
    print("profit_rates: " + str(profit_rates[-1]))

    et.selected_num = len(et.selected_model_types)
    ensemble_models = ""
    for i in range(len(et.selected_model_types)):
        ensemble_models = ensemble_models + et.selected_model_types[i] + "_"

    if et.trading_9h:
        path = "9시시가에거래_ensemble3_" + str(et.pred_term) + "_reinfo_" + str(et.reinfo_th) + \
               "_" + str(et.model_reinfo_th) + "_losscut_" + str(et.profit.loss_cut) + "_" + ensemble_models + ".xlsx"
    else:
        path = str(random.randint(1, 100)) + "_9시거래없음_ensemble3_" + str(et.pred_term) + "_reinfo_" + str(et.reinfo_th) + \
               "_" + str(et.model_reinfo_th) + "_losscut_" + str(et.profit.loss_cut) + "_" + ensemble_models + ".xlsx"

    path = folder + path

    #dic = {'dates': dates, 'profits': profit_sum, 'closes': closes, 'profit_rates': profit_rates}
    #pd.DataFrame(dic).to_excel(path, index=False, encoding='euc-kr')

    print(path)

    return dates, closes, close_rates, profit_rates, [path, calc_MDD(profit_rates), profit_product], ensemble_models

def calc_MDD(profit_rates):

    MDD = []
    for i in range(len(profit_rates)):
        MDD.append((profit_rates[:i+1].max() - profit_rates[i]) / profit_rates[:i+1].max())
    return np.array(MDD).max()

if __name__ == '__main__':
    result_path = "eval_reflection3/eval_reflection3_" + term + "_losscut" + str(et.profit.loss_cut) + ".csv"
    if os.path.isfile(result_path):
        results = pd.read_csv(result_path).values.tolist()
    else:
        results = []

    best = [0, 0, 0, 0, '']

    if not every_term_random:
        for enm in models:
            et.reinfo_th = enm[3]
            et.model_reinfo_th = enm[3]
            et.pred_term = enm[4]
            et.selected_model_types = enm[:3]

            ensemble_models = ""
            for i in range(len(et.selected_model_types)):
                ensemble_models = ensemble_models + et.selected_model_types[i] + "_"
            if not results == [] and [ensemble_models, str(et.reinfo_th), str(et.pred_term)] in np.array(results)[:,
                                                                                                :3].tolist():
                continue

            dates, closes, close_rates, profit_rates, profits, ensemble_models = main()

            results.append([ensemble_models, et.reinfo_th, et.pred_term, profit_rates[-1], profits[1], profits[2]])
            print([ensemble_models, et.reinfo_th, et.pred_term, profit_rates[-1], profits[1], profits[2]])

            pd.DataFrame(np.array(results),
                         columns=['ensemble', 'self-reflection', 'pred_term', 'profit_rates', 'MDD',
                                  'profit_product']).to_csv(result_path, index=False)

            if profit_rates[-1] > best[0]:
                best[0] = profit_rates[-1]
                best[1] = profits[2]
                best[2] = et.reinfo_th
                best[3] = et.pred_term
                best[4] = ensemble_models

            print("================= 중간 best >>>>>>>>>>>>>>>>>>>>>>>>>>>>")
            print(best)

    else:
        for i in range(random_cnt):

            dates, closes, close_rates, profit_rates, profits, ensemble_models = main()
            if not results == [] and [ensemble_models, str(et.reinfo_th), str(et.pred_term)] in np.array(results)[:,
                                                                                                :3].tolist():
                continue

            results.append([ensemble_models, et.reinfo_th, et.pred_term, profit_rates[-1], profits[1], profits[2]])
            print([ensemble_models, et.reinfo_th, et.pred_term, profit_rates[-1], profits[1], profits[2]])

            pd.DataFrame(np.array(results),
                         columns=['ensemble', 'self-reflection', 'pred_term', 'profit_rates', 'MDD',
                                  'profit_product']).to_csv(result_path, index=False)

            if profit_rates[-1] > best[0]:
                best[0] = profit_rates[-1]
                best[1] = profits[2]
                best[2] = et.reinfo_th
                best[3] = et.pred_term
                best[4] = ensemble_models


            print("================= 중간 best >>>>>>>>>>>>>>>>>>>>>>>>>>>>")
            print(best)

    print("최종 best >>>>")
    print(best)

    plt.figure(figsize=(10, 6))
    plt.plot(dates, close_rates, color='r', linewidth=3.0, label='kospi200 f index')
    ensemble_name = "ensemble " + ensemble_models
    plt.plot(dates, profit_rates, color='b', linewidth=3.0, label=ensemble_name)
    plt.legend()

    ax = plt.axes()
    ax.xaxis.set_major_locator(ticker.MultipleLocator(300))

    plt.xticks(rotation=30)

    plt.show()