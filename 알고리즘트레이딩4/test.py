# Copyright 2022 Bimghi Choi. All Rights Reserved.

# -*- coding:utf-8 -*-

# 여러 기능들에 대한 test

import tensorflow as tf
import pandas as pd
import numpy as np
import ensemble_test as et

a = []

a.append('1')

exit(0)

last_trains = [
    '2016-12-31',

    '2017-01-15', '2017-01-31', '2017-02-15', '2017-02-28',
    '2017-03-15', '2017-03-31', '2017-04-15', '2017-04-30',
    '2017-05-15', '2017-05-31', '2017-06-15', '2017-06-30',
    '2017-07-15', '2017-07-31', '2017-08-15', '2017-08-31',
    '2017-09-15', '2017-09-30', '2017-10-15', '2017-10-31',
    '2017-11-15', '2017-11-30', '2017-12-15',

    '2017-12-31',

    '2018-01-15', '2018-01-31', '2018-02-15', '2018-02-28',
    '2018-03-15', '2018-03-31', '2018-04-15', '2018-04-30',
    '2018-05-15', '2018-05-31', '2018-06-15', '2018-06-30',
    '2018-07-15', '2018-07-31', '2018-08-15', '2018-08-31',
    '2018-09-15', '2018-09-30', '2018-10-15', '2018-10-31',
    '2018-11-15', '2018-11-30', '2018-12-15',

    '2018-12-31',
    '2019-01-15', '2019-01-31', '2019-02-15', '2019-02-28',
    '2019-03-15', '2019-03-31', '2019-04-15', '2019-04-30',
    '2019-05-15', '2019-05-31', '2019-06-15', '2019-06-30',
    '2019-07-15', '2019-07-31', '2019-08-15', '2019-08-31',
    '2019-09-15', '2019-09-30', '2019-10-15', '2019-10-31',
    '2019-11-15', '2019-11-30', '2019-12-15',

    '2019-12-31',
    '2020-01-15', '2020-01-31', '2020-02-15', '2020-02-28',
    '2020-03-15', '2020-03-31', '2020-04-15', '2020-04-30',
    '2020-05-15', '2020-05-31', '2020-06-15', '2020-06-30',
    '2020-07-15', '2020-07-31', '2020-08-15', '2020-08-31',
    '2020-09-15', '2020-09-30', '2020-10-15', '2020-10-31',
    '2020-11-15', '2020-11-30', '2020-12-15',

    '2020-12-31',
    '2021-01-15', '2021-01-31', '2021-02-15', '2021-02-28',
    '2021-03-15', '2021-03-31', '2021-04-15', '2021-04-30',
    '2021-05-15', '2021-05-31', '2021-06-15', '2021-06-30',
    '2021-07-15', '2021-07-31', '2021-08-15', '2021-08-31',
    '2021-09-15', '2021-09-30', '2021-10-15', '2021-10-31',
    '2021-11-15', '2021-11-30', '2021-12-15',

    '2021-12-31',
    '2022-01-15', '2022-01-31', '2022-02-15', '2022-02-28',
    '2022-03-15', '2022-03-31', '2022-04-15',

    '2022-04-30',
    '2022-05-15', '2022-05-31', '2022-06-15', '2022-06-30',
    '2022-07-15', '2022-07-31', '2022-08-15', '2022-08-31',
    '2022-09-15', '2022-09-30', '2022-10-15', '2022-10-31',
    '2022-11-15', '2022-11-30', '2022-12-15', '2022-12-31',
    '2023-01-15', '2023-01-31', '2023-02-15', '2023-02-28',
    '2023-03-15', '2023-03-31', '2023-04-15', '2023-04-30',
    '2023-05-15',
]

start_times = [
    '2017/01/01/09:00', '2017/01/16/09:00', '2017/02/01/09:00', '2017/02/16/09:00',
    '2017/03/01/09:00', '2017/03/16/09:00', '2017/04/01/09:00', '2017/04/16/09:00',
    '2017/05/01/09:00', '2017/05/16/09:00', '2017/06/01/09:00', '2017/06/16/09:00',
    '2017/07/01/09:00', '2017/07/16/09:00', '2017/08/01/09:00', '2017/08/16/09:00',
    '2017/09/01/09:00', '2017/09/16/09:00', '2017/10/01/09:00', '2017/10/16/09:00',
    '2017/11/01/09:00', '2017/11/16/09:00', '2017/12/01/09:00', '2017/12/16/09:00',

    '2018/01/01/09:00', '2018/01/16/09:00', '2018/02/01/09:00', '2018/02/16/09:00',
    '2018/03/01/09:00', '2018/03/16/09:00', '2018/04/01/09:00', '2018/04/16/09:00',
    '2018/05/01/09:00', '2018/05/16/09:00', '2018/06/01/09:00', '2018/06/16/09:00',
    '2018/07/01/09:00', '2018/07/16/09:00', '2018/08/01/09:00', '2018/08/16/09:00',
    '2018/09/01/09:00', '2018/09/16/09:00', '2018/10/01/09:00', '2018/10/16/09:00',
    '2018/11/01/09:00', '2018/11/16/09:00', '2018/12/01/09:00', '2018/12/16/09:00',

    '2019/01/01/09:00', '2019/01/16/09:00', '2019/02/01/09:00', '2019/02/16/09:00',
    '2019/03/01/09:00', '2019/03/16/09:00', '2019/04/01/09:00', '2019/04/16/09:00',
    '2019/05/01/09:00', '2019/05/16/09:00', '2019/06/01/09:00', '2019/06/16/09:00',
    '2019/07/01/09:00', '2019/07/16/09:00', '2019/08/01/09:00', '2019/08/16/09:00',
    '2019/09/01/09:00', '2019/09/16/09:00', '2019/10/01/09:00', '2019/10/16/09:00',
    '2019/11/01/09:00', '2019/11/16/09:00', '2019/12/01/09:00', '2019/12/16/09:00',

    '2020/01/01/09:00', '2020/01/16/09:00', '2020/02/01/09:00', '2020/02/16/09:00',
    '2020/03/01/09:00', '2020/03/16/09:00', '2020/04/01/09:00', '2020/04/16/09:00',
    '2020/05/01/09:00', '2020/05/16/09:00', '2020/06/01/09:00', '2020/06/16/09:00',
    '2020/07/01/09:00', '2020/07/16/09:00', '2020/08/01/09:00', '2020/08/16/09:00',
    '2020/09/01/09:00', '2020/09/16/09:00', '2020/10/01/09:00', '2020/10/16/09:00',
    '2020/11/01/09:00', '2020/11/16/09:00', '2020/12/01/09:00', '2020/12/16/09:00',

    '2021/01/01/09:00', '2021/01/16/09:00', '2021/02/01/09:00', '2021/02/16/09:00',
    '2021/03/01/09:00', '2021/03/16/09:00', '2021/04/01/09:00', '2021/04/16/09:00',
    '2021/05/01/09:00', '2021/05/16/09:00', '2021/06/01/09:00', '2021/06/16/09:00',
    '2021/07/01/09:00', '2021/07/16/09:00', '2021/08/01/09:00', '2021/08/16/09:00',
    '2021/09/01/09:00', '2021/09/16/09:00', '2021/10/01/09:00', '2021/10/16/09:00',
    '2021/11/01/09:00', '2021/11/16/09:00', '2021/12/01/09:00', '2021/12/16/09:00',

    '2022/01/01/09:00', '2022/01/16/09:00', '2022/02/01/09:00', '2022/02/16/09:00',
    '2022/03/01/09:00', '2022/03/16/09:00', '2022/04/01/09:00', '2022/04/16/09:00',
    '2022/05/01/09:00', '2022/05/16/09:00', '2022/06/01/09:00', '2022/06/16/09:00',
    '2022/07/01/09:00', '2022/07/16/09:00', '2022/08/01/09:00', '2022/08/16/09:00',
    '2022/09/01/09:00', '2022/09/16/09:00', '2022/10/01/09:00', '2022/10/16/09:00',
    '2022/11/01/09:00', '2022/11/16/09:00', '2022/12/01/09:00', '2022/12/16/09:00',

    '2023/01/01/09:00', '2023/01/16/09:00', '2023/02/01/09:00', '2023/02/16/09:00',
    '2023/03/01/09:00', '2023/03/16/09:00', '2023/04/01/09:00', '2023/04/16/09:00',
    '2023/05/01/09:00', '2023/05/16/09:00',
]

end_times = [
    '2017/01/15/15:00', '2017/01/31/15:00', '2017/02/15/15:00', '2017/02/28/15:00',
    '2017/03/15/15:00', '2017/03/31/15:00', '2017/04/15/15:00', '2017/04/30/15:00',
    '2017/05/15/15:00', '2017/05/31/15:00', '2017/06/15/15:00', '2017/06/30/15:00',
    '2017/07/15/15:00', '2017/07/31/15:00', '2017/08/15/15:00', '2017/08/31/15:00',
    '2017/09/15/15:00', '2017/09/30/15:00', '2017/10/15/15:00', '2017/10/31/15:00',
    '2017/11/15/15:00', '2017/11/30/15:00', '2017/12/15/15:00', '2017/12/31/15:00',

    '2018/01/15/15:00', '2018/01/31/15:00', '2018/02/15/15:00', '2018/02/28/15:00',
    '2018/03/15/15:00', '2018/03/31/15:00', '2018/04/15/15:00', '2018/04/30/15:00',
    '2018/05/15/15:00', '2018/05/31/15:00', '2018/06/15/15:00', '2018/06/30/15:00',
    '2018/07/15/15:00', '2018/07/31/15:00', '2018/08/15/15:00', '2018/08/31/15:00',
    '2018/09/15/15:00', '2018/09/30/15:00', '2018/10/15/15:00', '2018/10/31/15:00',
    '2018/11/15/15:00', '2018/11/30/15:00', '2018/12/15/15:00', '2018/12/31/15:00',


    '2019/01/15/15:00', '2019/01/31/15:00', '2019/02/15/15:00', '2019/02/28/15:00',
    '2019/03/15/15:00', '2019/03/31/15:00', '2019/04/15/15:00', '2019/04/30/15:00',
    '2019/05/15/15:00', '2019/05/31/15:00', '2019/06/15/15:00', '2019/06/30/15:00',
    '2019/07/15/15:00', '2019/07/31/15:00', '2019/08/15/15:00', '2019/08/31/15:00',
    '2019/09/15/15:00', '2019/09/30/15:00', '2019/10/15/15:00', '2019/10/31/15:00',
    '2019/11/15/15:00', '2019/11/30/15:00', '2019/12/15/15:00', '2019/12/31/15:00',

    '2020/01/15/15:00', '2020/01/31/15:00', '2020/02/15/15:00', '2020/02/28/15:00',
    '2020/03/15/15:00', '2020/03/31/15:00', '2020/04/15/15:00', '2020/04/30/15:00',
    '2020/05/15/15:00', '2020/05/31/15:00', '2020/06/15/15:00', '2020/06/30/15:00',
    '2020/07/15/15:00', '2020/07/31/15:00', '2020/08/15/15:00', '2020/08/31/15:00',
    '2020/09/15/15:00', '2020/09/30/15:00', '2020/10/15/15:00', '2020/10/31/15:00',
    '2020/11/15/15:00', '2020/11/30/15:00', '2020/12/15/15:00', '2020/12/31/15:00',

    '2021/01/15/15:00', '2021/01/31/15:00', '2021/02/15/15:00', '2021/02/28/15:00',
    '2021/03/15/15:00', '2021/03/31/15:00', '2021/04/15/15:00', '2021/04/30/15:00',
    '2021/05/15/15:00', '2021/05/31/15:00', '2021/06/15/15:00', '2021/06/30/15:00',
    '2021/07/15/15:00', '2021/07/31/15:00', '2021/08/15/15:00', '2021/08/31/15:00',
    '2021/09/15/15:00', '2021/09/30/15:00', '2021/10/15/15:00', '2021/10/31/15:00',
    '2021/11/15/15:00', '2021/11/30/15:00', '2021/12/15/15:00', '2021/12/31/15:00',

    '2022/01/15/15:00', '2022/01/31/15:00', '2022/02/15/15:00', '2022/02/28/15:00',
    '2022/03/15/15:00', '2022/03/31/15:00', '2022/04/15/15:00', '2022/04/30/15:00',
    '2022/05/15/15:00', '2022/05/31/15:00', '2022/06/15/15:00', '2022/06/30/15:00',
    '2022/07/15/15:00', '2022/07/31/15:00', '2022/08/15/15:00', '2022/08/31/15:00',
    '2022/09/15/15:00', '2022/09/30/15:00', '2022/10/15/15:00', '2022/10/31/15:00',
    '2022/11/15/15:00', '2022/11/30:15:00', '2022/12/15/15:00', '2022/12/31/15:00',

    '2023/01/15/15:00', '2023/01/31/15:00', '2023/02/15/15:00', '2023/02/28/15:00',
    '2023/03/15/15:00', '2023/03/31/15:00', '2023/04/15/15:00', '2023/04/30/15:00',
    '2023/05/15/15:00', '2023/05/31/15:00',
]

selected_model_types = ['15P', '25C', '5HL']

start_time = '2021/01/01/09:00'
end_time = '2021/01/31/15:00'

start_index = start_times.index(start_time)
end_index = end_times.index(end_time)

last_trains = last_trains[start_index:end_index+1]
start_times = start_times[start_index:end_index+1]
end_times = end_times[start_index:end_index+1]

# 모델별 각 구간별 수익률 계산, 저장
profit_sum = []
profit_product = 1
profits = np.empty(0)
dates = np.empty(0)
# closes = np.empty(0)
closes = pd.DataFrame()
for i in range(len(last_trains)):
    et.last_train = last_trains[i]
    et.start_time = start_times[i]
    et.end_time = end_times[i]

    et.weights = [1 for i in range(et.selected_num)]
    et.selected_checkpoint_path = ['' for i in range(et.selected_num)]

    et.df_pred_path = et.last_train + '/kospi200f_60M_pred.csv'
    et.df_raw_path = et.last_train + '/kospi200f_60M_raw.csv'
    et.result_path = et.last_train + '/pred_83_results.csv'

    for j in range(et.selected_num):
        et.selected_checkpoint_path[j] = et.last_train + "/60M_" + selected_model_types[j] + "_best"

    # for j in range(et.selected_num):
    #    et.selected_checkpoint_path[j] = et.last_train + "/60M_" + df.values[j, i] + "_best"
    #    et.selected_checkpoint_path[j] = et.last_train + "/60M_" + model_pools[j] + "_best"

    et.preprocessing()
    p = et.predict()
    print(last_trains[i] + " 수익률: " + str(p))
    profit_sum.append(p)  # max(p, 0.5)
    profit_product *= p  # max(p, 0.5)

    df = pd.read_csv(et.result_path, encoding='euc-kr')
    profit = df['profit'].values - df['fee'].values
    # if sum(profit) / 8000000 + 1 < 0.5:
    #    profit[:] = 0
    #    profit[len(profit)-1] = -4000000
    profits = np.concatenate([profits, profit], axis=0)
    dates = np.concatenate([dates, df['date'].values], axis=0)
    # closes = np.concatenate([closes, df['close'].values], axis=0)
    closes = pd.concat([closes, df['close']], ignore_index=True, axis=0)

close_accm = closes.expanding().mean().values.transpose()
profit_accm = profits.cumsum()
profit_rates = profit_accm / (close_accm * 1.25 * 250000 * 0.075) + 1  # 8000000 + 1
close_rates = (np.array(closes) - closes[0]) / (closes.mean() * 1.25 * 0.075) + 1  # *250000/8000000 + 1

import tensorflow_hub as hub
from transformers import BertTokenizer

tokenizer = BertTokenizer.from_pretrained('tokenizer_tf2_qa')
model = hub.load("https://tfhub.dev/see--/bert-uncased-tf2-qa/1")

questions = [
    'How long did it take to find the answer?',
    'What\'s the answer to the great question?',
    'What\'s the name of the computer?']
paragraph = '''<p>The computer is named Deep Thought.</p>.
               <p>After 46 million years of training it found the answer.</p>
               <p>However, nobody was amazed. The answer was 42.</p>'''

for question in questions:
  question_tokens = tokenizer.tokenize(question)
  paragraph_tokens = tokenizer.tokenize(paragraph)
  tokens = ['[CLS]'] + question_tokens + ['[SEP]'] + paragraph_tokens + ['[SEP]']
  input_word_ids = tokenizer.convert_tokens_to_ids(tokens)
  input_mask = [1] * len(input_word_ids)
  input_type_ids = [0] * (1 + len(question_tokens) + 1) + [1] * (len(paragraph_tokens) + 1)

  input_word_ids, input_mask, input_type_ids = map(lambda t: tf.expand_dims(
      tf.convert_to_tensor(t, dtype=tf.int32), 0), (input_word_ids, input_mask, input_type_ids))
  outputs = model([input_word_ids, input_mask, input_type_ids])
  # using `[1:]` will enforce an answer. `outputs[0][0][0]` is the ignored '[CLS]' token logit
  short_start = tf.argmax(outputs[0][0][1:]) + 1
  short_end = tf.argmax(outputs[1][0][1:]) + 1
  answer_tokens = tokens[short_start: short_end + 1]
  answer = tokenizer.convert_tokens_to_string(answer_tokens)
  print(f'Question: {question}')
  print(f'Answer: {answer}')